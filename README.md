# LeetCodeEveryDay
目前做过的题目，以及思路整理

- 1.2Sum：使用Map保存数字状态
- 2.两个数字之和：链表加和
- 3.cool:无重复字符的最长子串(medium)：滑动窗口，用map保存窗口内每个字符的最后出现位置，有冲突直接跳到那个位置后面
- 5.oncemore:最长回文子串：把每一个值和值中间的槽作为中点，然后左右延伸，得到最大值，然后循环一周
- 6.z字变换:找到规律，然后进行循环加即可。
- 7.整数翻转:循环余10，然后将余数乘10保存起来，然后进行累计。
- 8.字符串转换整数:重点在于判断是否进行数字的字符中，然后记住正负，然后乘。
- 9.oncemore:回文数:求翻转数字，相等即可（注意范围，用long保存）优化点：翻转一半就可以
- 11.oncemore:乘最多水的容器:左右两个指针，记住最大值，由小数向大数移动
- 12.整数转罗马数字:整理规则即可
- 13.罗马数组转整数:整理规则即可
- 14.最长公共前缀:得到第一个词的字符，拿去套其他字符串，进行遍历即可。
- 19.oncemore:删除链表倒数第n个节点:保存n+1个节点,注意头结点问题。
- 20.有效的括号:放到栈里，只有左括号匹配右括号才能弹出，看是不是还剩下。
- 21.合并两个有效链表:进行合并即可,长度不一致可以进行直接连接的优化。
- 26.oncemore:删除排序数组中的重复项:双指针法。
- 27.移除元素:双指针法，前后向中间迭代
- 28.cool:实现strStr():字符串模式匹配
- 35.oncemore:搜索插入位置:二分搜索,注意边界条件
- 36.有效的数独:三个二维数组保存行列宫的数字是否存在。
- 38.oncemore:报数:递归报数
- 48.旋转图像:沿对角线翻转，然后再左右翻转
- 53.oncemore:最大子序和
    - 动态规划，如果前面的所有的和小于零，就抛弃前面的结果 
    - 分治法
- 58.最后一个单词的长度:从后往前遍历，找到最后一个单词就行了
- 66.加一:倒序遍历，如果位数多了一位使用arraycopy
- 67.二进制求和:倒序遍历，和加一类似
- 69.oncemore:x 的平方根:
    - 二分搜索
    - 牛顿迭代法
- 70.爬楼梯:斐波那契数列，用数组保存之前的结果
- 83.删除排序链表中的重复元素:遇到相等就进行删除节点操作
- 88.合并两个有序数组:进行倒序的归并
- 94.二叉树的中序遍历
    - 递归
    - 迭代，使用队列和Set进行迭代
- 98.cool:验证二叉搜索树:
    - 递归：
    - 迭代：中序遍历出数组，这个数组是升序
- 100.相同的树:任意遍历，全部相同即可，或者递归也可以
- 101.oncemore:对称二叉树:
    - 递归：进行镜像操作，左孩子的左节点和右孩子的右节点相同，左孩子的右节点和右孩子的左节点相同
    - 迭代：
- 102.二叉树的层次遍历:
    - oncemore:递归：递归带着level
    - 迭代：广度优先遍历
- 104.oncemore:二叉树的最大深度:用Pair保存当前节点的深度，然后进行DFS
- 108.将有序数组转换为二叉搜索树:二分构建二叉树
- 118.帕斯卡三角形:循环即可
- 121.买卖股票的最佳时机:问题同53，最大子序和，如果之前的结果会造成损失，就抛弃之前的结果。
- 122.买卖股票的最佳时机 II : 用贪心算法，只要涨了就卖
- 125.验证回文串:前后两个指针遍历
- 133.克隆图:深度优先遍历，递归方法。
- 136.只出现一次的数字:异或两次相当于没有异或
- 141.环形链表:双指针法，相遇即为有环
- 142.环形链表 II:双指针法，相遇之后，把快指针重置，两个指针同步移动，返回再次相遇的位置
- 150.逆波兰表达式求值：使用栈进行计算
- 155.最小栈:用两个栈
- 169.oncemore:求众数:使用count统计，遇到不同减一，count为零将值设为当前值
- 189.旋转数组
    - 左边翻转一次，右边翻转一次，全部翻转一次
    - oncemore:递归方法
- 190.oncemore:翻转整数:将倒数第n位设为最后一位后，进行右移
- 191.位1的个数：每次与自己减一进行且操作，直到为零，有一个1就操作几次
- 200.岛屿的个数：广度优先遍历
- 204.oncemore:计算质数:
    - 埃拉托色尼筛选法:https://blog.csdn.net/qq_37653144/article/details/80470029
- 206.oncemore:反转链表
    - 迭代：双指针法
    - 递归
- 217.存在重复元素:排序之后，相等就返回错误
- 225.用队列实现栈:两个队列
- 232.用栈实现队列:两个栈
- 234.oncemore:回文链表:双指针法确定中间点，然后翻转后半部分
- 237.删除链表中的节点:迭代将后一个节点修改为前一个节点，然后删除最后一个节点
- 240.搜索二维矩阵 II:从最左下角开始搜索，如果小于它，向上，如果大于它，向右
- 242.有效的字母异位词:用Map保存字符个数
- 268.缺失数字
- 278.第一个错误的版本：二分搜索 注意 int mid = left+(right-left)/2;
- 279.完全平方数：BFS，第一个匹配的就是最快的
- 283.oncemore:移动零:用双指针法，慢指针停在0的位置，快指针停在非零的位置时，进行交换。
- 326.3的幂：数论，n如果也是3的幂次，故而题目中所给整数范围内最大的3的幂次的因子只能是3的幂次
- 344.反转字符串:双指针前后交换
- 350.两个数组的交集 II:排序后一次遍历，相等就加入结果集，没有就把大的节点移动
- 384.打乱数组
- 387.字符串中的第一个唯一字符:用桶保存初始位置，重复设为-2
- 394.字符串解码:使用栈进行交互
- 412.FizzBuzz
- 461.汉明距离
    - 1.用一个游标进行移动判断
    - 2.先异或，然后求1的个数
- 494.oncemore:目标和
    - 1.DFS递归搜索
    - 2.01背包问题，动态规划
- 622.循环队列:注意边界条件，tail指向下一个位置，head指向当前位置
- 739.每日温度:使用栈作为辅助队列，用来保存下标
- 752.oncemore:打开转盘锁:广度优先遍历





